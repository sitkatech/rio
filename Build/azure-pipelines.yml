resources:
  repositories:
  - repository: self
    type: git
    ref: develop

    
stages:
- stage: Test
  displayName: Test All
  condition: and(succeeded(), eq(variables['runTests'], 'true'))
  jobs:  
  - job: TestAPI
    displayName: 'Test API'
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    steps:
    - task: DotNetCoreCLI@2
      displayName: 'dotnet restore'
      inputs:
        command: restore
        projects: 'Rio.UnitTest\Rio.UnitTest.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet build'
      inputs:
        projects: 'Rio.UnitTest\Rio.UnitTest.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet test'
      inputs:
        command: test
        projects: 'Rio.UnitTest\Rio.UnitTest.csproj'


- stage: BuildWeb
  displayName: Build API/Web
  dependsOn: Test
  condition: in(dependencies.Test.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
  jobs:
  - job: BuildAPI
    displayName: Build API
    condition: eq(variables['build'], 'true')
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
    - task: DockerCompose@0
      displayName: Build API services
      inputs:
        azureSubscriptionEndpoint: '$(azureCRSubscription)'
        azureContainerRegistry: '$(containerRegistry)'
        dockerComposeFile: docker-compose/docker-compose.yml
        dockerComposeFileArgs: env=$(environment)
        action: Build services
        additionalImageTags: >-
          $(Build.BuildNumber)-$(environment)

          $(environment)
        includeLatestTag: true

    - task: DockerCompose@0
      displayName: Push API Image to Registry  
      condition: eq(variables['pushImages'], 'true')
      inputs:
        azureSubscriptionEndpoint: '$(azureCRSubscription)'
        azureContainerRegistry: '$(containerRegistry)'
        dockerComposeFile: docker-compose/docker-compose.yml
        dockerComposeFileArgs: env=$(environment)
        action: Push services
        additionalImageTags: >-
          $(Build.BuildNumber)-$(environment)

          $(environment)
        includeLatestTag: true


  - job: BuildWeb
    displayName: Build Web
    condition: eq(variables['build'], 'true')
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
    - task: CmdLine@2
      displayName: Overwrite SCSS variables for $(tenantName)
      inputs:
        script: cp Rio.Web/src/scss/_variables_$(tenantName).scss Rio.Web/src/scss/_variables.scss
    - task: DockerCompose@0
      displayName: Build Web services
      inputs:
        azureSubscriptionEndpoint: '$(azureCRSubscription)'
        azureContainerRegistry: '$(containerRegistry)'
        dockerComposeFile: Rio.Web/docker-compose/docker-compose.yml
        dockerComposeFileArgs: env=$(environment)
        action: Build services
        additionalImageTags: >-
          $(Build.BuildNumber)-$(environment)

          $(environment)
        includeLatestTag: true


    - task: DockerCompose@0
      displayName: Push Web Image to Registry  
      condition: eq(variables['pushImages'], 'true')
      inputs:
        azureSubscriptionEndpoint: '$(azureCRSubscription)'
        azureContainerRegistry: '$(containerRegistry)'      
        dockerComposeFile: Rio.Web/docker-compose/docker-compose.yml
        dockerComposeFileArgs: env=$(environment)
        action: Push services
        additionalImageTags: >-
          $(Build.BuildNumber)-$(environment)

          $(environment)
        includeLatestTag: true
    

- stage: BuildTerraform
  displayName: Terraform Plan
  dependsOn: Test
  condition: in(dependencies.Test.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')  
  jobs:
  - job: Terraform
    displayName: Terraform Plan
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    steps:
    - task: AzureCLI@1
      displayName: 'Azure CLI'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptLocation: inlineScript
        inlineScript: |
          call az storage account create --name $(storageAccountName) --resource-group $(azureApplicationTfStateResourceGroup) --location westus --sku Standard_LRS
          
          call az storage container create --name terraform --account-name $(storageAccountName)
          
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '0.14.11'

    - task: TerraformCLI@0
      inputs:
        command: 'init'
        backendType: 'azurerm'
        backendServiceArm: '$(azureSubscription)'
        #backendAzureRmSubscriptionId: 'a'
        ensureBackend: true
        backendAzureRmResourceGroupName: '$(azureApplicationTfStateResourceGroup)'
        backendAzureRmResourceGroupLocation: 'WestUS2'
        backendAzureRmStorageAccountName: '$(storageAccountName)'
        backendAzureRmContainerName: 'terraform'
        #backendAzureRmKey: 'd'
        allowTelemetryCollection: true

    - task: TerraformCLI@0
      inputs:
        command: 'plan'
        environmentServiceName: '$(azureSubscription)'
        commandOptions: '-var "appInsightsName=$(appInsightsName)" -var "keyVaultName=$(keyVaultName)" -var "storageAccountName=$(storageAccountApplicationName)" -var "resourceGroupName=$(resourceGroupName)" -var "dbServerName=$(dbServerName)" -var "aspNetEnvironment=$(aspNetEnvironment)" -var "databaseName=$(databaseName)" -var "databaseEdition=$(databaseEdition)" -var "databaseTier=$(databaseTier)" -var "sqlPassword=$(sqlPassword)" -var "sqlUsername=$(sqlUsername)"'
        allowTelemetryCollection: true
        publishPlanResults: 'tfplan'
        
    - publish: 'tfplan'
      artifact: plan
      
    - publish: 'rio.tf'
      artifact: terraform
    
    - task: CopyFiles@2
      inputs:
        sourceFolder: 'charts/$(tenantName)'
        contents: '**'
        targetFolder: $(Build.ArtifactStagingDirectory)/chart
      condition: and(succeeded(), eq(variables['deploy'], 'true'))

    - task: PublishBuildArtifacts@1
      inputs:
        artifactName: ChartArtifacts
        pathtoPublish: $(Build.ArtifactStagingDirectory)
      condition: and(succeeded(), eq(variables['deploy'], 'true'))

    - task: PublishBuildArtifacts@1
      inputs:
        artifactName: GeoServerArtifacts
        pathtoPublish: 'Rio.GeoServer/data_dir'
      condition: and(succeeded(), eq(variables['deploy'], 'true'))



- stage: BuildDB
  displayName: Build DB
  dependsOn: Test
  condition: in(dependencies.Test.result, 'Succeeded', 'SucceededWithIssues', 'Skipped')
  jobs:
  - template: templates/dacpac-template.yml
    parameters:
      name: 'Database'
      solutionFile: 'Rio.Database/Rio.Database.sqlproj'
      additionalArgs: '/p:DSP=Microsoft.Data.Tools.Schema.Sql.SqlAzureV12DatabaseSchemaProvider'
      publishPath: 'Rio.Database/bin/Debug/Rio.Database.dacpac'
      artifactName: 'Database'



- stage: DeployTerraform
  displayName: Deploy Terraform (with Approval)
  dependsOn: 
    - BuildWeb
    - BuildDB
    - BuildTerraform
  condition: |
    and
    (
      in(dependencies.BuildWeb.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.BuildDB.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.BuildTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Terraform
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    # creates an environment if it doesn't exist
    environment: '$(Environment)-Approve' # this Environment has an Approval Gate attached to it in the Azure DevOps UI
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: terraform
                  
          - task: TerraformInstaller@0
            inputs:
              terraformVersion: '0.14.11'

          - task: TerraformCLI@0
            inputs:
              command: 'init'
              workingDirectory: '$(Pipeline.Workspace)/terraform'
              backendType: 'azurerm'
              backendServiceArm: '$(azureSubscription)'
              ensureBackend: true
              backendAzureRmResourceGroupName: '$(azureApplicationTfStateResourceGroup)'
              backendAzureRmResourceGroupLocation: 'WestUS2'
              backendAzureRmStorageAccountName: '$(storageAccountName)'
              backendAzureRmContainerName: 'terraform'
              allowTelemetryCollection: true

          - task: TerraformCLI@0
            inputs:
              command: 'apply'
              workingDirectory: '$(Pipeline.Workspace)/terraform'
              environmentServiceName: '$(azureSubscription)'
              commandOptions: '-var "appInsightsName=$(appInsightsName)" -var "keyVaultName=$(keyVaultName)" -var "storageAccountName=$(storageAccountApplicationName)" -var "resourceGroupName=$(resourceGroupName)" -var "dbServerName=$(dbServerName)" -var "aspNetEnvironment=$(aspNetEnvironment)" -var "databaseName=$(databaseName)" -var "databaseEdition=$(databaseEdition)" -var "databaseTier=$(databaseTier)" -var "sqlPassword=$(sqlPassword)" -var "sqlUsername=$(sqlUsername)"'
              allowTelemetryCollection: true

          - task: TerraformCLI@0
            displayName: 'Terraform output'
            inputs:
              command: 'output'
              workingDirectory: '$(Pipeline.Workspace)/terraform'
              
          - bash: |
              echo "##vso[task.setvariable variable=STORAGE_ACCOUNT_SAS_KEY;isOutput=true]$(TF_OUT_STORAGE_ACCOUNT_SAS_KEY)"
              echo "##vso[task.setvariable variable=APPLICATION_STORAGE_ACCOUNT_KEY;isOutput=true]$(TF_OUT_APPLICATION_STORAGE_ACCOUNT_KEY)"
              echo "##vso[task.setvariable variable=INSTRUMENTATION_KEY;isOutput=true]$(TF_OUT_INSTRUMENTATION_KEY)"
          - bash: 'env | sort'

- stage: DeployDB
  displayName: Deploy Database 
  dependsOn: DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Database
    pool:
      vmImage: 'windows-latest'
      demands: msbuild
    # creates an environment if it doesn't exist
    environment: $(Environment)
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: Database 
          
          - task: DownloadPipelineArtifact@2
            inputs:
              source: 'specific'
              project: 'Rio'
              pipeline: '$(databaseName) Backup Job'
              runVersion: 'latest'
              artifact: bacpac  
              path: '$(Pipeline.Workspace)/bacpac'
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))

          - task: SqlAzureDacpacDeployment@1
            displayName: 'Azure SQL InlineSqlTask - Clean Up Old QA DB'
            inputs:
              azureSubscription: '$(azureSubscription)'
              ServerName: '$(dbServer)' 
              DatabaseName: master
              SqlUsername: '$(sqlUsername)'
              SqlPassword: '$(sqlPassword)'
              deployType: InlineSqlTask
              SqlInline: |
                if exists (select * from sys.databases where name = '$(databaseName)_qa')
                begin
                  drop database $(databaseName)_qa
                end            
                
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))

          - task: SqlAzureDacpacDeployment@1
            displayName: 'Azure SQL InlineSqlTask - Import Prod BacPac'
            inputs:
              azureSubscription: '$(azureSubscription)'
              ServerName: '$(dbServer)' 
              DatabaseName: '$(databaseName)_prod'
              SqlUsername: '$(sqlUsername)'
              SqlPassword: '$(sqlPassword)'
              DeploymentAction: Import
              BacpacFile: '$(Pipeline.Workspace)/bacpac/$(databaseName).bacpac'
              AdditionalArguments: '/p:DatabaseEdition=$(databaseEdition) /p:DatabaseServiceObjective=$(databaseTier)'
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))

          - task: SqlAzureDacpacDeployment@1
            displayName: 'Azure SQL DacpacTask'
            inputs:
              azureSubscription: '$(azureSubscription)'
              ServerName: '$(dbServer)' 
              DatabaseName: '$(databaseName)_prod'
              SqlUsername: '$(sqlUsername)'
              SqlPassword: '$(sqlPassword)'
              DacpacFile: '$(Pipeline.Workspace)/Database/Rio.Database.dacpac'
              AdditionalArguments: '/p:GenerateSmartDefaults=true /p:BlockOnPossibleDataLoss=false /p:CommandTimeout=600 /TargetTimeout:600 /p:DatabaseEdition=$(databaseEdition) /p:DatabaseServiceObjective=$(databaseTier)'
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))

          - task: SqlAzureDacpacDeployment@1
            displayName: 'Azure SQL DacpacTask NoRestore'
            inputs:
              azureSubscription: '$(azureSubscription)'
              ServerName: '$(dbServer)' 
              DatabaseName: '$(databaseName)'
              SqlUsername: '$(sqlUsername)'
              SqlPassword: '$(sqlPassword)'
              DacpacFile: '$(Pipeline.Workspace)/Database/Rio.Database.dacpac'
              AdditionalArguments: '/p:GenerateSmartDefaults=true /p:BlockOnPossibleDataLoss=false /p:CommandTimeout=600 /TargetTimeout:600 /p:DatabaseEdition=$(databaseEdition) /p:DatabaseServiceObjective=$(databaseTier)'
            condition: and(succeeded(), eq(variables['restoreDatabase'], false))

          - task: SqlAzureDacpacDeployment@1
            displayName: 'Azure SQL InlineSqlTask - Swap DBs'
            inputs:
              azureSubscription: '$(azureSubscription)'
              ServerName: '$(dbServer)' 
              DatabaseName: master
              SqlUsername: '$(sqlUsername)'
              SqlPassword: '$(sqlPassword)'
              deployType: InlineSqlTask
              SqlInline: |
                ALTER DATABASE $(databaseName) MODIFY NAME = $(databaseName)_qa                
                GO                
                ALTER DATABASE $(databaseName)_prod MODIFY NAME = $(databaseName)                
                GO
                drop database $(databaseName)_qa
              
            condition: and(succeeded(), eq(variables['restoreDatabase'], true))


- stage: DeployGeoServer
  displayName: Deploy GeoServer
  dependsOn: DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: GeoServer
    pool:
      vmImage: 'windows-latest'
    variables: 
      STORAGE_ACCOUNT_SAS_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.STORAGE_ACCOUNT_SAS_KEY'] ]
    # creates an environment if it doesn't exist
    environment: $(Environment)
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:        
          - download: current
            artifact: GeoServerArtifacts
          - bash: |
              echo "variable value is $(STORAGE_ACCOUNT_SAS_KEY)"
             
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'ps'
              scriptLocation: 'inlineScript'
              inlineScript: |
                azcopy copy "$(Pipeline.Workspace)\GeoServerArtifacts\*" "https://$(storageAccountApplicationName).file.core.windows.net/geoserver/data_dir/$(STORAGE_ACCOUNT_SAS_KEY)" --from-to=LocalFile --recursive


- stage: DeployHelm
  displayName: Deploy Helm
  dependsOn: 
  - DeployGeoServer
  - DeployDB
  - DeployTerraform
  condition: |
    and
    (
      in(dependencies.DeployGeoServer.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.DeployDB.result, 'Succeeded', 'SucceededWithIssues'),
      in(dependencies.DeployTerraform.result, 'Succeeded', 'SucceededWithIssues'),
      eq(variables['deploy'], 'true')
    )
  jobs:  
  - deployment: Helm
    pool:
      vmImage: 'ubuntu-latest'
    variables: 
      APPLICATION_STORAGE_ACCOUNT_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.APPLICATION_STORAGE_ACCOUNT_KEY'] ]
      INSTRUMENTATION_KEY: $[ stageDependencies.DeployTerraform.Terraform.outputs['Terraform.Bash.INSTRUMENTATION_KEY'] ]
    # creates an environment if it doesn't exist
    environment: $(Environment)
    strategy:
      # default deployment strategy, more coming...
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: ChartArtifacts
                        
          - task: HelmInstaller@0
            displayName: 'Install Helm 3.8.0'
            inputs:
              helmVersion: 3.8.0
              installKubectl: true

          - task: Kubernetes@1
            displayName: 'kubectl login'
            inputs:
              connectionType: Azure Resource Manager
              azureSubscriptionEndpoint: '$(azureSubscription)'
              azureResourceGroup: '$(azureClusterResourceGroup)'
              kubernetesCluster: '$(kubernetesCluster)'
              command: login

          - task: HelmDeploy@0
            displayName: 'helm upgrade $(tenantName)'
            inputs:
              connectionType: Azure Resource Manager
              azureSubscription: '$(azureSubscription)'
              azureResourceGroup: '$(azureClusterResourceGroup)'
              kubernetesCluster: '$(kubernetesCluster)'
              command: upgrade
              chartType: FilePath
              chartPath: '$(Pipeline.Workspace)/ChartArtifacts/chart'
              releaseName: '$(tenantName)'
              overrideValues: 'global.env.appInsightsInstrumentationKey="$(INSTRUMENTATION_KEY)",global.domains.api="$(domainApi)",global.domains.web="$(domainWeb)",global.domains.geoserver="$(domainGeoserver)",global.env.name="$(Environment)",global.secrets.geoserverSqlServerPassword="$(GeoserverSqlServerPassword)",global.secrets.geoserverAdminPassword="$(GeoserverAdminPassword)",global.secrets.geoserverAzureStorageAccountName="$(storageAccountApplicationName)",global.secrets.geoserverAzureStorageAccountKey="$(APPLICATION_STORAGE_ACCOUNT_KEY)",global.env.dbServer=$(dbServer),global.env.databaseName=$(databaseName),global.env.sqlUsername=$(sqlUsername),global.secrets.apiSqlPassword=$(sqlPassword),global.secrets.sendGridApiKey="$(SendGridApiKey)"'
              force: false
                      